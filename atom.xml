<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Raylee's Blog]]></title>
  <subtitle><![CDATA[Just like to share, just enjoy!]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://liray.github.io/"/>
  <updated>2014-04-27T10:42:51.070Z</updated>
  <id>http://liray.github.io/</id>
  
  <author>
    <name><![CDATA[Ray Lee]]></name>
    <email><![CDATA[wisconsion@qq.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[已经把博客迁移到Github]]></title>
    <link href="http://liray.github.io/2014/04/26/migrate-to-hexo-from-wordpress-now/"/>
    <id>http://liray.github.io/2014/04/26/migrate-to-hexo-from-wordpress-now/</id>
    <published>2014-04-26T10:41:27.000Z</published>
    <updated>2014-04-27T05:20:21.000Z</updated>
    <content type="html"><![CDATA[<p>2008年，为了能方便随时查看自己收藏的精品文章，决定把这些文章都整理到网上，我第一次接触博客，那个时候试用了很多博客，不是编辑排版太麻烦，就是主题太难搞，有些还有兼容性问题，最后选了网易博客，至于是什么原因选了网易博客，现在我已经不再记得。</p>
<p>2010还是2011开始，为了FQ我搭建了GAE，那时GAE还没支持php站点，但支持python语言，将就的按照网上的教程搭建了python程序的博客，成功搭建后，使用过程却非常纠结，不方便，所以这个python程序博客名也已经不记得了。但我的折腾精神依旧坚定，一心想搭建Wordpress，继续寻找可以搭建免费php站点的空间商，期间我找的几个免费空间商都不满意，可能是我的要求太高了，毕竟免费的空间限制肯定多。寻找过程中我学到了很多，例如域名设置、LMNP、LAMP的搭建等等。</p>
<p>终于2012年4月，找到了Openshift，并且还幸运的申请到了个1年免费的ME顶级域名，对我来说这个空间除了速度慢了点，几乎没有其他缺点，空间也足够我用，是个非常棒的开发测试用空间，直至现在已经使用2年了，但我很少更新博客文章，笔记几乎都写在了Evernote里，懒得更新到Wordpress上，懒的原因太多。</p>
<ul>
<li>第一懒：访问查看文章的时候有点慢，这我觉得没什么，但是写文章的时候就有点痛苦，特别是上传图片；</li>
<li>第二懒：Wordpress已经不能满足我的需求，我需要的是无网络时能实时查看和编辑文章，我觉得这个Wordpress可以做到，但是配置一定会非常麻烦，但我就是懒，我只是想专注于写作和笔记；</li>
<li>第三懒：博客程序无需复杂的设置，马上就能在本地和远程空间做同步，方便快捷，随时随地写博客；</li>
<li>第四懒：总是担心空间被黑；</li>
<li>第…</li>
</ul>
<p>我果然非常懒，但折腾精神仍旧旺盛。最近由于想做个项目，接触下开源软件，然后了解了下Git、Markdown等，无意中看到了Github搭建博客的文章，当然Github能搭建博客是我从用Openshift开始就知道了，那时候看了下只能搭建静态网站，所以就没太去留意，但是这个文章却出乎我意料，给了我很多惊喜，满足了我各种懒惰需求。什么易读Markdown语法、随时随地写文章只需文本编辑器、版本控制（安全还原文件）、本地实时查看和编辑文章（秒速访问）、没有复杂的设置等等，这些的这些实在是太美妙了，这就是我非常想要的，这就是Github+Node.js+Hexo，这配合写博客是如此强大，太简单太美了！</p>
<p>这两天开始折腾下，熟悉了下配置（也没什么地方要设置的），把Wordpress文章整理到Hexo，一切是多么简单和顺利，个性域名什么的就先不理会，Github自带的这个2级域名也没有怨念，<em>就这样专注写文章吧</em>，该文就作为开博开篇文章，Enjoying！(竟然能把该啰嗦文看完，你太牛X了！)</p>
]]></content>
    
    
      <category term="hexo" scheme="http://liray.github.io/tags/hexo/"/>
    
      <category term="wordpress" scheme="http://liray.github.io/tags/wordpress/"/>
    
      <category term="github" scheme="http://liray.github.io/tags/github/"/>
    
      <category term="openshift" scheme="http://liray.github.io/tags/openshift/"/>
    
      <category term="生活趣事" scheme="http://liray.github.io/categories/%E7%94%9F%E6%B4%BB%E8%B6%A3%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[内核, 模块, 驱动]]></title>
    <link href="http://liray.github.io/2013/08/17/linux-kernel-modules-drivers/"/>
    <id>http://liray.github.io/2013/08/17/linux-kernel-modules-drivers/</id>
    <published>2013-08-17T15:12:38.000Z</published>
    <updated>2014-04-27T10:42:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2>
<ul>
<li>Linux 是一个配备了多种硬件类型内置驱动程序的内核.</li>
<li>但是对于较新的硬件, 安装程序并不是总能配置一个合适的驱动…</li>
<li>…或是在我们发行版的内核中找不到相应的驱动程序.</li>
<li>在这些情况下, 我们会想去找到一个正确的驱动安装并且配置它, 使得能够正常工作.</li>
<li>这次的讲座里, 我们将会获得一个”怎样做”的初步想法.</li>
</ul>
<blockquote>
<p>  Once again, remember what sets off “the hitch-hikers guide to the galaxy(银河系漫游指南)” from “the encyclopedia Galactica(银河系百科全书)”: It has, written on its top, the phrase: Don’t Panic!</p>
</blockquote>
<a id="more"></a>

<h2 id="Linux_内核">Linux 内核</h2>
<ul>
<li>是一个作为操作系统的计算机程序.</li>
<li>允许应用程序以更加通用的方式访问硬件.</li>
<li>使得在系统启动时获得加载, 并启动进程, 使我们能够登录并运行程序.</li>
<li>是由驻留在一个单独的文件, 和一堆只有它们需要时才加载的较小的模块所组成一个”核心”.</li>
</ul>
<h3 id="内核,_进程和硬件">内核, 进程和硬件</h3>
<p>如果我们画一个操作系统的抽象布局设计, 它可能看起来像下图:</p>
<p><img src="/images/2013/08/17/a9b813e83b8a3834d35ec11d9010017f484a4c7e.png" alt="操作系统的抽象布局设计" title="操作系统的抽象布局设计"></p>
<h2 id="硬件诊断">硬件诊断</h2>
<ul>
<li>为了给各种硬件配置驱动程序, 我们首先必须正确的识别它.</li>
<li>通常情况下, 我们买来的产品的名称是未知的, 或者过于笼统.</li>
<li>我们最感兴趣的是什么呢? 就是在硬件设备中找到的制造商名称和芯片(组)模块…</li>
<li>…因为这就是驱动程序最终要与之通讯的.</li>
</ul>
<h3 id="lspci_命令">lspci 命令</h3>
<ul>
<li>使我们能够在系统里识别硬件型号.</li>
<li>提供的这些是PCI卡(而不是旧的ISA卡).<br>输出如下:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>[choo@simey ~]$ /sbin/lspci 
<span class="number">00</span>:<span class="number">00.0</span> Host bridge: VIA Technologies, <span class="keyword">Inc</span>.: Unknown device <span class="number">3189</span>
<span class="number">00</span>:<span class="number">01.0</span> PCI bridge: VIA Technologies, <span class="keyword">Inc</span>.: Unknown device b168
<span class="number">00</span>:<span class="number">0</span>a<span class="number">.0</span> Communication controller: Conexant HSF <span class="number">56</span>k HSFi Modem (rev <span class="number">01</span>)
<span class="number">00</span>:<span class="number">0</span>b<span class="number">.0</span> Ethernet controller: Realtek Semiconductor Co., Ltd. RTL-<span class="number">8139</span>/<span class="number">8139</span>C (rev <span class="number">10</span>)
<span class="number">00</span>:<span class="number">0</span>c<span class="number">.0</span> Multimedia audio controller: Creative Labs SB Live! EMU10k1 (rev <span class="number">0</span>a)
<span class="number">00</span>:<span class="number">0</span>c<span class="number">.1</span> Input device controller: Creative Labs SB Live! MIDI/Game Port (rev <span class="number">0</span>a)
<span class="number">00</span>:<span class="number">10.0</span> USB Controller: VIA Technologies, <span class="keyword">Inc</span>. USB (rev <span class="number">80</span>)
<span class="number">00</span>:<span class="number">10.1</span> USB Controller: VIA Technologies, <span class="keyword">Inc</span>. USB (rev <span class="number">80</span>)
<span class="number">00</span>:<span class="number">10.2</span> USB Controller: VIA Technologies, <span class="keyword">Inc</span>. USB (rev <span class="number">80</span>)
<span class="number">00</span>:<span class="number">10.3</span> USB Controller: VIA Technologies, <span class="keyword">Inc</span>. USB <span class="number">2.0</span> (rev <span class="number">82</span>)
<span class="number">00</span>:<span class="number">11.0</span> ISA bridge: VIA Technologies, <span class="keyword">Inc</span>.: Unknown device <span class="number">3177</span>
<span class="number">00</span>:<span class="number">11.1</span> IDE interface: VIA Technologies, <span class="keyword">Inc</span>. Bus Master IDE (rev <span class="number">06</span>)
<span class="number">00</span>:<span class="number">13.0</span> Ethernet controller: Realtek Semiconductor Co., Ltd. RTL-<span class="number">8139</span>/<span class="number">8139</span>C (rev <span class="number">10</span>)
<span class="number">01</span>:<span class="number">00.0</span> VGA compatible controller: nVidia Corporation NV17 [GeForce4 MX440] (rev a3)
</pre></td></tr></table></figure>

<p>一个调制解调器(modem), 2块声卡, 2块网卡, 一个USB接口, 一个IDE控制器, 和一个屏幕控制器.</p>
<h3 id="使用你的眼睛">使用你的眼睛</h3>
<ul>
<li>附注: 当你的内核不能识别一些硬件设备时, 才使用这种方法 (例如: 原因是这些硬件在全球首次发售前, 你的Linux发行版就发布了).</li>
<li>打开你的电脑机箱(如果这些设备是在机箱内).</li>
<li>搜寻你想看到的硬件设备.</li>
<li>查看最大的那个芯片, 读取其标签.</li>
<li>记下全部的内容, 把一部分内容放到Google搜索.</li>
</ul>
<h3 id="通过_/proc_目录验证">通过 /proc 目录验证</h3>
<ul>
<li><code>/proc</code>目录是一个虚拟的目录, 它允许直接与运行中的Linux内核交互.</li>
<li>当我们试图去打印某个文件时, 内核就会立刻(on-the-fly:实时)生成它的内容. 在这个目录里是没有真实的磁盘文件存在的.</li>
<li><p>以下是一些有趣的的硬件诊断文件(使用<code>cat &lt;源文件&gt;</code>命令来查看它们):</p>
<ul>
<li><code>/proc/interrupts</code> - 不同的驱动程序目前所使用的IRQ中断号列表.</li>
<li><code>/proc/ioports</code> - 驱动程序目前所使用的I/O地址列表.</li>
<li><code>/proc/pci</code> - 关于PCI驱动程序的信息.</li>
<li><code>/proc/cpuinfo</code> - 关于我们CPU的信息.</li>
</ul>
</li>
</ul>
<h2 id="设备文件">设备文件</h2>
<ul>
<li>代表硬件设备到用户模式应用程序.</li>
<li>第一眼看起来像是普通的文件.</li>
<li>不包含任何数据 - 它们只用做通讯用.</li>
<li>使用<code>ls -l</code>, 第一字母是<code>c</code>或<code>b</code>要取决于设备的类型(将在后面说明).</li>
<li>有一个主要的数字, 它描述了设备的类型.</li>
<li>有一个次要的数字, 它描述了设备的实例(允许多个相同类型的设备).</li>
<li>看起来像这样:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>[choo<span class="variable">@simey</span> ~]<span class="variable">$ </span>ls -l /dev/hda
brw-rw----    <span class="number">1</span> root     disk       <span class="number">3</span>,   <span class="number">0</span> <span class="constant">Apr</span> <span class="number">11</span>  <span class="number">2002</span> /dev/hda
[choo<span class="variable">@simey</span> ~]<span class="variable">$ </span>ls -l /dev/ttyS1
crw-rw----    <span class="number">1</span> root     uucp       <span class="number">4</span>,  <span class="number">65</span> <span class="constant">Apr</span> <span class="number">11</span>  <span class="number">2002</span> /dev/ttyS1
</pre></td></tr></table></figure>

<h3 id="/dev_目录">/dev 目录</h3>
<ul>
<li>系统中所有设备文件的标准路径…</li>
<li>…但是它能够在其他的目录创建设备文件(例如RedHat安装过程中, 在<code>/tmp</code>目录会创建硬盘的设备文件).</li>
<li><p>例如常见的文件名字如下:</p>
<ul>
<li><code>hda</code> - 首个IDE设备(硬盘, CDROM).</li>
<li><code>hdb3</code> - 第2个IDE设备的第2个分区(必须是硬盘. CDROM是没有分区的).</li>
<li><code>ttyS0</code> - 首个串行端口(“COM1”).</li>
<li><code>sda1</code> - 首个SCSI设备的第一个分区 (硬盘, 一个仿真SCSI设备, 等等.).</li>
<li><code>lp0</code> - 首个并行端口(LPT1).</li>
</ul>
</li>
</ul>
<h3 id="字符设备_Vs-_块设备">字符设备 Vs. 块设备</h3>
<ul>
<li>字符设备(<code>c</code>)是一个通过发送和接受单个字符(字节, 8位字节)与驱动程序进行通信.</li>
<li>块设备(<code>b</code>)是一个通过发送全部数据块与驱动程序进行通信.</li>
<li>举个字符设备的例子: 串行端口, 并行端口, 声卡.</li>
<li>举个块设备的例子: 硬盘, USB摄像头, 闪存盘.</li>
<li>写给用户, 设备类型(块设备或字符设备)并不重要 - 你只要关心硬盘的分区和声卡.</li>
<li>然而, 驱动程序员必须关心, 但是这些超出了我们的范围.</li>
</ul>
<h2 id="内核模块">内核模块</h2>
<ul>
<li>为了减少Linux内核的大小, 它会被分为一个’核心(core:内核)’, 和大量的内核模块.</li>
<li>一个内核模块是能被运行中的内核随意加载或卸载的小文件(下一代Linux内核将不再允许卸载模块, 除非另有告知).</li>
<li>内核的很多功能能被直接编译到内核中, 或编译成模块.</li>
<li>这种设计使得可以更快的加载内核(无需加载或初始化不必要的模块), 以及开发驱动程序(如果你发现了一个bug, 只要卸载模块, 再修复它, 重新编译后, 并再加载它一遍).</li>
</ul>
<h3 id="使用_lsmod_命令列出加载的模块">使用 lsmod 命令列出加载的模块</h3>
<p>为了看到当前加载的模块列表, 使用<code>lsmod</code>命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>[choo@simey ~]$ /sbin/lsmod 
<span class="keyword">Module</span>                  Size  Used <span class="keyword">by</span>    <span class="keyword">Not</span> tainted
ppp_synctty             <span class="number">6368</span>   <span class="number">0</span> (unused)
ppp_async               <span class="number">8032</span>   <span class="number">1</span>
ppp_generic            <span class="number">23692</span>   <span class="number">3</span> [ppp_synctty ppp_async]
slhc                    <span class="number">6220</span>   <span class="number">0</span> [ppp_generic]
ipt_LOG                 <span class="number">4384</span>  <span class="number">19</span> (autoclean)
ipt_TCPMSS              <span class="number">3168</span>   <span class="number">1</span> (autoclean)
iptable_nat            <span class="number">19668</span>   <span class="number">1</span> (autoclean)
ip_conntrack           <span class="number">20268</span>   <span class="number">1</span> (autoclean) [iptable_nat]
iptable_filter          <span class="number">2464</span>   <span class="number">1</span> (autoclean)
ip_tables              <span class="number">13632</span>   <span class="number">6</span> [ipt_LOG ipt_TCPMSS iptable_nat iptable_filter]
vfat                   <span class="number">11804</span>   <span class="number">1</span> (autoclean)
fat                    <span class="number">36184</span>   <span class="number">0</span> (autoclean) [vfat]
ext3                   <span class="number">64800</span>   <span class="number">3</span> (autoclean)
jbd                    <span class="number">47924</span>   <span class="number">3</span> (autoclean) [ext3]
emu10k1                <span class="number">60832</span>   <span class="number">1</span>
ac97_codec             <span class="number">12256</span>   <span class="number">0</span> [emu10k1]
sound                  <span class="number">69260</span>   <span class="number">0</span> [emu10k1]
soundcore               <span class="number">6212</span>   <span class="number">7</span> [emu10k1 sound]
mousedev                <span class="number">5024</span>   <span class="number">1</span>
hid                    <span class="number">20608</span>   <span class="number">0</span> (unused)
input                   <span class="number">5696</span>   <span class="number">0</span> [mousedev hid]
ehci-hcd               <span class="number">16864</span>   <span class="number">0</span> (unused)
usb-uhci               <span class="number">24292</span>   <span class="number">0</span> (unused)
usbcore                <span class="number">71104</span>   <span class="number">1</span> [hid ehci-hcd usb-uhci]
</pre></td></tr></table></figure>

<h3 id="/lib/modules_目录">/lib/modules 目录</h3>
<ul>
<li>包含了我们已经安装的不同内核版本的模块.</li>
<li>每个内核一个以内核版本号命名的目录.</li>
<li><p>模块根据类别分别存放于各目录.</p>
<ul>
<li><code>pcmcia</code> - 笔记本的 PCMCIA 驱动程序.</li>
<li><code>kernel/net</code> - 与网络相关的模块(防火墙, 额外支持的协议等等…).</li>
<li><code>kernel/drivers</code> - 各类硬件驱动程序(包括网络驱动程序).</li>
<li><code>kernel/fs</code> - 文件系统支持(ext3, vfat等等…).</li>
<li><code>kernel/arch</code> - 特定于体系结构的支持(例如:用来处理特定CPU或主板功能的驱动程序).</li>
</ul>
</li>
</ul>
<h2 id="加载和卸载内核模块_-_insmod/rmmod">加载和卸载内核模块 - insmod/rmmod</h2>
<ul>
<li>模块的加载和卸载仅能通过root来执行.</li>
<li>使用<code>insmod</code>命令加载一个内核模块:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>[root@simey ~]<span class="preprocessor"># insmod eeprom</span>
<span class="keyword">Using</span> /<span class="keyword">lib</span>/modules/<span class="number">2.4</span><span class="number">.18</span>-<span class="number">17.7</span>.x/kernel/drivers/sensors/eeprom.o
</pre></td></tr></table></figure>

<p>使用<code>lsmod</code>检查, 确认模块已被加载.</p>
<ul>
<li>使用<code>rmmod</code>命令卸载一个内核模块:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>[root<span class="variable">@simey</span> ~]<span class="comment"># rmmod eeprom</span>
</pre></td></tr></table></figure>

<p>使用<code>lsmod</code>检查, 确认模块已被加载.</p>
<h3 id="处理内核模块的依赖_-_depmod_和_modprobe">处理内核模块的依赖 - depmod 和 modprobe</h3>
<ul>
<li>模块可以互相依赖. 例如, 如果加载模块<code>lm78</code>, 我们首先需要加载<code>i2c-core</code>和<code>i2c-proc</code>.</li>
<li>使用<code>depmod</code>命令构建一个模块依赖列表 - 即以便加载每个模块所需的其他模块. 运行如下:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>[root@simey ~]<span class="preprocessor"># depmod -a</span>
<span class="label">depmod:</span> *** Unresolved symbols <span class="keyword">in</span>
         /lib/modules/<span class="number">2.4</span><span class="number">.18</span>-<span class="number">17.7</span><span class="preprocessor">.x</span>/kernel/arch/i386/kernel/longhaul<span class="preprocessor">.o</span>
<span class="label">depmod:</span> *** Unresolved symbols <span class="keyword">in</span>
         /lib/modules/<span class="number">2.4</span><span class="number">.18</span>-<span class="number">17.7</span><span class="preprocessor">.x</span>/kernel/arch/i386/kernel/p4-clockmod<span class="preprocessor">.o</span>
<span class="label">depmod:</span> *** Unresolved symbols <span class="keyword">in</span>
         /lib/modules/<span class="number">2.4</span><span class="number">.18</span>-<span class="number">17.7</span><span class="preprocessor">.x</span>/kernel/arch/i386/kernel/speedstep<span class="preprocessor">.o</span>
</pre></td></tr></table></figure>

<ul>
<li>为了使系统自动照顾这些加载的依赖, 使用<code>modprobe</code>命令加载一个模块:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>[root<span class="variable">@simey</span> ~]<span class="comment"># modprobe lm78</span>
</pre></td></tr></table></figure>

<p>或使输出详细的信息:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>[root@simey ~]<span class="preprocessor"># modprobe -v lm78</span>
/sbin/insmod /<span class="keyword">lib</span>/modules/<span class="number">2.4</span><span class="number">.18</span>-<span class="number">17.7</span>.x/kernel/drivers/i2c/i2c-core.o
<span class="keyword">Using</span> /<span class="keyword">lib</span>/modules/<span class="number">2.4</span><span class="number">.18</span>-<span class="number">17.7</span>.x/kernel/drivers/i2c/i2c-core.o
Symbol version prefix <span class="comment">''</span>
/sbin/insmod /<span class="keyword">lib</span>/modules/<span class="number">2.4</span><span class="number">.18</span>-<span class="number">17.7</span>.x/kernel/drivers/i2c/i2c-proc.o
<span class="keyword">Using</span> /<span class="keyword">lib</span>/modules/<span class="number">2.4</span><span class="number">.18</span>-<span class="number">17.7</span>.x/kernel/drivers/i2c/i2c-proc.o
/sbin/insmod /<span class="keyword">lib</span>/modules/<span class="number">2.4</span><span class="number">.18</span>-<span class="number">17.7</span>.x/kernel/drivers/sensors/lm78.o
<span class="keyword">Using</span> /<span class="keyword">lib</span>/modules/<span class="number">2.4</span><span class="number">.18</span>-<span class="number">17.7</span>.x/kernel/drivers/sensors/lm78.o
</pre></td></tr></table></figure>

<h3 id="/etc/modules-conf文件">/etc/modules.conf文件</h3>
<ul>
<li>我们使用的模块通常包含”默认”参数(例如网络驱动程序, 声卡等等…).</li>
<li>常用命令行:<ul>
<li><code>alias</code> - 指定为一个给定的硬件设备使用一个给定的模块(驱动程序). 例如:<br><code>alias eth0 8139too</code></li>
<li><code>options</code> - 给一个被加载的给定的模块提供选项. 例如:<br><code>options sb io=0x220 irq=5 dma=1 dma16=0 mpu_io=0x310</code></li>
</ul>
</li>
<li>附注: 模块选项也可以被当做参数供给<code>insmod</code>和<code>modprobe</code>命令.</li>
</ul>
<h3 id="获得一个内核模块的信息_-_modinfo">获得一个内核模块的信息 - modinfo</h3>
<ul>
<li>为了获得一个模块的信息(作者, 所提供的选项), 我们可以使用<code>modinfo</code>命令.</li>
<li>例如有关<code>mousedev</code>模块的信息:</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>[choo@simey ~]$ /sbin/modinfo mousedev
<span class="label">filename:</span>    /lib/modules/<span class="number">2.4</span><span class="number">.18</span>-<span class="number">17.7</span><span class="preprocessor">.x</span>/kernel/drivers/input/mousedev<span class="preprocessor">.o</span>
<span class="label">description:</span> <span class="string">"Input driver to PS/2 or ImPS/2 device driver"</span>
<span class="label">author:</span>      <span class="string">"Vojtech Pavlik "</span>
<span class="label">license:</span>     <span class="string">"GPL"</span>
<span class="label">parm:</span>        xres int, description <span class="string">"Horizontal screen resolution"</span>
<span class="label">parm:</span>        yres int, description <span class="string">"Vertical screen resolution"</span>
</pre></td></tr></table></figure>

<ul>
<li>也能使用模块的源代码获得关于它的信息. 在某种情况下, 在源代码文件的顶部会有很多有趣的注释.</li>
</ul>
<h2 id="标准的内核驱动程序">标准的内核驱动程序</h2>
<ul>
<li>许多驱动程序做为发行版内核的一部分. 使用它们.</li>
<li>正如我们所看到的, 这些驱动程序被存储在<code>/lib/modules/</code>目录中.</li>
<li>有时候这些模块文件名将暗示它支持的硬件类型.</li>
<li>往往我们可以通过Google搜索获得模块的名称, 假设我们寻找芯片组, 而不是硬件的商品名称.</li>
<li>最终在产品制造公司的网站寻找, 或许有提供芯片组的驱动程序. 如果我们幸运的话, 这个驱动程序已经是我们内核的一部分, 并且我们不需要再去下载它.</li>
</ul>
<h3 id="如果我们的驱动程序没有被编译呢?">如果我们的驱动程序没有被编译呢?</h3>
<ul>
<li>一些驱动程序或许来自于我们内核源代码的一部分, 然而仍然不被编译进发行版的默认内核.</li>
<li>我们能够在内核源码树中寻找到驱动程序…</li>
<li>…或者可以在网上阅读到它的存在, 或者在内核源代码的文档中(<code>/usr/src/linux/Documentation</code>).</li>
<li>为了编译这个驱动, 我们将需要执行一次完整内核的编译, 然后才会编译驱动程序.</li>
<li>通常在第二次后, 我们将不再需要重新编译整个内核 - 仅仅是第二个驱动程序.</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>我们涵盖了Linux内核与进程之间, 和Linux内核与硬件之间的交互.</li>
<li>我们看到了什么是内核模块, 以及如何管理它们.</li>
<li>我们学习了设备文件和它们的用途.</li>
<li>我们学习了识别计算机硬件.</li>
</ul>
<p>第一次翻译文章, 有任何翻译不到位的地方请多多指教.</p>
<p><strong>原文地址 <a href="http://haifux.org/lectures/86-sil/kernel-modules-drivers/kernel-modules-drivers.html" title="kernel, modules, drivers" target="_blank">kernel, modules, drivers @guy keren</a></strong><br><strong>译文由 @<a href="/" title="Raylee&#39;s blog">Ray Lee</a> 翻译</strong></p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="介绍">介绍</h2>
<ul>
<li>Linux 是一个配备了多种硬件类型内置驱动程序的内核.</li>
<li>但是对于较新的硬件, 安装程序并不是总能配置一个合适的驱动…</li>
<li>…或是在我们发行版的内核中找不到相应的驱动程序.</li>
<li>在这些情况下, 我们会想去找到一个正确的驱动安装并且配置它, 使得能够正常工作.</li>
<li>这次的讲座里, 我们将会获得一个”怎样做”的初步想法.</li>
</ul>
<blockquote>
<p>  Once again, remember what sets off “the hitch-hikers guide to the galaxy(银河系漫游指南)” from “the encyclopedia Galactica(银河系百科全书)”: It has, written on its top, the phrase: Don’t Panic!</p>
</blockquote>
]]></summary>
    
      <category term="driver" scheme="http://liray.github.io/tags/driver/"/>
    
      <category term="kernel" scheme="http://liray.github.io/tags/kernel/"/>
    
      <category term="linux" scheme="http://liray.github.io/tags/linux/"/>
    
      <category term="module" scheme="http://liray.github.io/tags/module/"/>
    
      <category term="translation" scheme="http://liray.github.io/tags/translation/"/>
    
      <category term="内核" scheme="http://liray.github.io/tags/%E5%86%85%E6%A0%B8/"/>
    
      <category term="模块" scheme="http://liray.github.io/tags/%E6%A8%A1%E5%9D%97/"/>
    
      <category term="译文" scheme="http://liray.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="驱动" scheme="http://liray.github.io/tags/%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="Linux 系统维护" scheme="http://liray.github.io/categories/Linux%20%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Beyond Compare 3提示许可证密码已经被撤销的解决方法]]></title>
    <link href="http://liray.github.io/2013/07/13/the-way-to-solve-the-licence-key-was-being-undo-for-bc3/"/>
    <id>http://liray.github.io/2013/07/13/the-way-to-solve-the-licence-key-was-being-undo-for-bc3/</id>
    <published>2013-07-13T07:46:29.000Z</published>
    <updated>2014-04-27T04:30:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题出现">问题出现</h2>
<p>今天打开BC又出现许可证过期错误, 以前也出现过这种情况, 只是一直没有记录:</p>
<p><img src="/images/2013/07/13/8bff82a51c6e43a22591d5b6c2df2ca6332a234e.png" alt="beyond compare 3 错误提示"><br><a id="more"></a></p>
<h2 id="解决方法">解决方法</h2>
<p>请务必完成以下步骤:</p>
<ol>
<li>删除BC安装目录下的<code>BC3Key.txt 文件</code>;</li>
<li>删除<code>%userprofile%\Application Data文件夹</code>里的<code>Scooter Software文件夹</code>;</li>
<li>重新运行软件, 就会弹出<code>初始化配置向导</code>, 在<code>注册</code>页面, 单击<code>输入密钥...</code>, 在弹出的对话框重新输入以前的KEY就OK了!<br><img src="/images/2013/07/13/4bb55b5f0108ff195f0fc45d2c03adaf2bf0332e.png" alt="BC3 初始化向导"></li>
</ol>
<p>搞定, Enjoy!!</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="问题出现">问题出现</h2>
<p>今天打开BC又出现许可证过期错误, 以前也出现过这种情况, 只是一直没有记录:</p>
<p><img src="/images/2013/07/13/8bff82a51c6e43a22591d5b6c2df2ca6332a234e.png" alt="beyond compare 3 错误提示"><br>]]></summary>
    
      <category term="beyond compare" scheme="http://liray.github.io/tags/beyond%20compare/"/>
    
      <category term="密钥" scheme="http://liray.github.io/tags/%E5%AF%86%E9%92%A5/"/>
    
      <category term="许可证" scheme="http://liray.github.io/tags/%E8%AE%B8%E5%8F%AF%E8%AF%81/"/>
    
      <category term="软件" scheme="http://liray.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="过期" scheme="http://liray.github.io/tags/%E8%BF%87%E6%9C%9F/"/>
    
      <category term="Windows" scheme="http://liray.github.io/tags/Windows/"/>
    
      <category term="Windows 系统维护" scheme="http://liray.github.io/categories/Windows%20%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cygwin 默认没有 clear 清屏命令!]]></title>
    <link href="http://liray.github.io/2013/05/16/cygwin-do-not-have-clear-command/"/>
    <id>http://liray.github.io/2013/05/16/cygwin-do-not-have-clear-command/</id>
    <published>2013-05-16T06:38:32.000Z</published>
    <updated>2014-04-26T09:22:06.000Z</updated>
    <content type="html"><![CDATA[<p>我使用 Linux 清屏的习惯是敲<code>clear</code>命令, 今天在 Cygwin 中使用<code>clear</code>命令却出现<code>-bash: clear: command not found</code>, 于是找到了几个清屏的方法:</p>
<ol>
<li>bash script处理 : <code>echo -e &quot;\E[2J&quot;^C</code></li>
<li>使用快捷键 : <code>Ctrl + L</code></li>
<li>运行 Cygwin Setup <code>安装 ncurses (in Utils) 包</code>, 就可以使用 clear 命令了</li>
</ol>
]]></content>
    
    
      <category term="bash" scheme="http://liray.github.io/tags/bash/"/>
    
      <category term="clear" scheme="http://liray.github.io/tags/clear/"/>
    
      <category term="command" scheme="http://liray.github.io/tags/command/"/>
    
      <category term="cygwin" scheme="http://liray.github.io/tags/cygwin/"/>
    
      <category term="编程相关" scheme="http://liray.github.io/categories/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解决 Cygwin 中使用 Git 出现证书验证错误]]></title>
    <link href="http://liray.github.io/2013/05/16/cygwin-got-an-error-setting-certificate-with-using-git/"/>
    <id>http://liray.github.io/2013/05/16/cygwin-got-an-error-setting-certificate-with-using-git/</id>
    <published>2013-05-16T06:30:47.000Z</published>
    <updated>2014-04-27T04:34:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题出现">问题出现</h2>
<p>今天在 Cygwin 使用 Git 时出现了证书验证错误, 在 Git 访问 https 连接的 git 仓库会报错:<br><img src="/images/2013/05/16/ca5b4365c69b61ded0f6ed1340a43432f1f6008f.png" alt="Cygwin Git 出错信息"><br><a id="more"></a></p>
<h2 id="解决方法">解决方法</h2>
<p>究其原因, 根据错误提示, 发现<code>/usr/ssl/certs/</code>目录下并没有<code>ca-bundle.crt 文件</code>, 是由缺少证书所造成的. 那么我们只要添加这些证书即可, 方法是使用<code>Cygwin Setup</code>安装<code>ca-certificates</code>包就 OK 了, Enjoying !!<br><img src="/images/2013/05/16/f2458b7d8fa6202bebc3d1f2e18cced2546998df.png" alt="Cygwin Setup 安装 ca-certificates 包"></p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="问题出现">问题出现</h2>
<p>今天在 Cygwin 使用 Git 时出现了证书验证错误, 在 Git 访问 https 连接的 git 仓库会报错:<br><img src="/images/2013/05/16/ca5b4365c69b61ded0f6ed1340a43432f1f6008f.png" alt="Cygwin Git 出错信息"><br>]]></summary>
    
      <category term="certificates" scheme="http://liray.github.io/tags/certificates/"/>
    
      <category term="cygwin" scheme="http://liray.github.io/tags/cygwin/"/>
    
      <category term="git" scheme="http://liray.github.io/tags/git/"/>
    
      <category term="https" scheme="http://liray.github.io/tags/https/"/>
    
      <category term="编程相关" scheme="http://liray.github.io/categories/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[你的 CPU 符合安装 Windows 8 的要求吗?]]></title>
    <link href="http://liray.github.io/2013/05/14/your-cpu-meet-windows-8-requirements/"/>
    <id>http://liray.github.io/2013/05/14/your-cpu-meet-windows-8-requirements/</id>
    <published>2013-05-14T07:04:13.000Z</published>
    <updated>2014-04-27T04:43:38.000Z</updated>
    <content type="html"><![CDATA[<p>可能已经有朋友遇到过某些 PC 不能安装 Win8 的情况了, 先看看官方列出的 Windows 8 推荐配置:</p>
<h2 id="PC_安装_Windows_8_推荐配置">PC 安装 Windows 8 推荐配置</h2>
<ul>
<li><strong>处理器</strong>：1 GHz 或更快（支持 PAE、NX 和 SSE2）</li>
<li><strong>RAM</strong>：1 GB（32 位）或 2 GB（64 位）</li>
<li><strong>硬盘空间</strong>：16 GB（32 位）或 20 GB（64 位）</li>
<li><strong>图形卡</strong>：带有 WDDM 驱动程序的 Microsoft DirectX 9 图形设备</li>
</ul>
<p>其中官方强调了些细节, Win8 的安装需要 CPU 支持 PAE、NX 和 SSE2 指令集, 不然无法安装 Win8, 先来了解一下这三个指令集:</p>
<ul>
<li><strong>PAE</strong> : 支持 32 位处理器可以访问 4 GB 以上物理内存功能版本的 Windows, 并且它是 NX 的先决条件.</li>
<li><strong>NX</strong> : 可让处理器帮助保护电脑免受恶意软件的攻击.</li>
<li><strong>SSE2</strong> (一项使用已久的关于处理器的标准) : 是一套由越来越多的第三方应用和驱动程序使用的指令集.</li>
</ul>
<p>引用官方的说法:</p>
<blockquote>
<p>对于 Windows 8, 要让恶意软件防御功能正常使用, 我们要求你的 处理器支持 NX. 若要增强在Windows 8中运行的第三方应用和驱动程序的可靠性, 还需要 SSE2. 如果你的电脑不支持 PAE、NX 和 SSE2, 你将无法安装 Windows 8.</p>
</blockquote>
<p>说了那么多, 我们如何检测 PC 的 CPU 是否支持上面的几个指令呢? 接下来我将使用 AIDA64 查看 CPU 的详细信息.<br><a id="more"></a></p>
<h2 id="检测_CPU_是否支持_SSE2">检测 CPU 是否支持 SSE2</h2>
<p>这个比较简单, 也可使用 CPU-Z来查看. AIDA64 左边树状图 -&gt; CPUID -&gt; 指令集中查看(如图) :</p>
<p><img src="/images/2013/05/14/28b3cd94e40502756bf2b9992646ebf939a4f039.png" alt="AIDA64 CPU SSE2 支持检测 - 1"><br><img src="/images/2013/05/14/29b84b0e87c1d07b9ab32eb9e890ba00d4e494a4.png" alt="AIDA64 CPU SSE2 支持检测 - 2"></p>
<h2 id="检测_CPU_是否支持_PAE">检测 CPU 是否支持 PAE</h2>
<p>AIDA64 左边树状图 -&gt; CPUID -&gt; 安全特性中(如图) :</p>
<p><img src="/images/2013/05/14/74b12bf76f2862d892e8d4a556934a0bd30dece0.png" alt="AIDA64 CPU PAE 支持检测"></p>
<h2 id="检测_CPU_是否支持_NX">检测 CPU 是否支持 NX</h2>
<p>AIDA64 左边树状图 -&gt; CPUID -&gt; 其他特性中(如图) :</p>
<p><img src="/images/2013/05/14/b0374933a7c84f08e860771a9136d4943e87d91d.png" alt="AIDA64 CPU NX 支持检测"></p>
<p>当然你也可以使用MS自家的检测工具: <a href="http://windows.microsoft.com/zh-cn/windows-8/upgrade-to-windows-8" title="更新到 Windows 8" target="_blank">Win 8 升级助手以及检测操作说明</a></p>
<p><em>提醒</em>安装 Windows 8 的朋友, 如果你的 PC 太旧, 最好先使用 AIDA64 来检测 CPU 是否支持 PAE 和 NX 指令, 然后再安装 Win8 !</p>
<h2 id="推荐参考">推荐参考</h2>
<ul>
<li><a href="http://windows.microsoft.com/en-us/windows-8/system-requirements" title="Windows 8 system requirements" target="_blank">Windows 8 system requirements</a></li>
<li><a href="http://windows.microsoft.com/zh-cn/windows-8/upgrade-to-windows-8" title="更新到 Windows 8" target="_blank">更新到 Windows 8</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>可能已经有朋友遇到过某些 PC 不能安装 Win8 的情况了, 先看看官方列出的 Windows 8 推荐配置:</p>
<h2 id="PC_安装_Windows_8_推荐配置">PC 安装 Windows 8 推荐配置</h2>
<ul>
<li><strong>处理器</strong>：1 GHz 或更快（支持 PAE、NX 和 SSE2）</li>
<li><strong>RAM</strong>：1 GB（32 位）或 2 GB（64 位）</li>
<li><strong>硬盘空间</strong>：16 GB（32 位）或 20 GB（64 位）</li>
<li><strong>图形卡</strong>：带有 WDDM 驱动程序的 Microsoft DirectX 9 图形设备</li>
</ul>
<p>其中官方强调了些细节, Win8 的安装需要 CPU 支持 PAE、NX 和 SSE2 指令集, 不然无法安装 Win8, 先来了解一下这三个指令集:</p>
<ul>
<li><strong>PAE</strong> : 支持 32 位处理器可以访问 4 GB 以上物理内存功能版本的 Windows, 并且它是 NX 的先决条件.</li>
<li><strong>NX</strong> : 可让处理器帮助保护电脑免受恶意软件的攻击.</li>
<li><strong>SSE2</strong> (一项使用已久的关于处理器的标准) : 是一套由越来越多的第三方应用和驱动程序使用的指令集.</li>
</ul>
<p>引用官方的说法:</p>
<blockquote>
<p>对于 Windows 8, 要让恶意软件防御功能正常使用, 我们要求你的 处理器支持 NX. 若要增强在Windows 8中运行的第三方应用和驱动程序的可靠性, 还需要 SSE2. 如果你的电脑不支持 PAE、NX 和 SSE2, 你将无法安装 Windows 8.</p>
</blockquote>
<p>说了那么多, 我们如何检测 PC 的 CPU 是否支持上面的几个指令呢? 接下来我将使用 AIDA64 查看 CPU 的详细信息.<br>]]></summary>
    
      <category term="AIDA64" scheme="http://liray.github.io/tags/AIDA64/"/>
    
      <category term="CPU" scheme="http://liray.github.io/tags/CPU/"/>
    
      <category term="NX" scheme="http://liray.github.io/tags/NX/"/>
    
      <category term="PAE" scheme="http://liray.github.io/tags/PAE/"/>
    
      <category term="SSE2" scheme="http://liray.github.io/tags/SSE2/"/>
    
      <category term="Windows" scheme="http://liray.github.io/tags/Windows/"/>
    
      <category term="Windows 8" scheme="http://liray.github.io/tags/Windows%208/"/>
    
      <category term="Windows 系统维护" scheme="http://liray.github.io/categories/Windows%20%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为"计算机"添加"以管理员身份打开"右键菜单, 解决 Windows 8 无法拖拽打开文件]]></title>
    <link href="http://liray.github.io/2013/05/09/open-computer-as-administrator-add-to-computer-s-context-menu/"/>
    <id>http://liray.github.io/2013/05/09/open-computer-as-administrator-add-to-computer-s-context-menu/</id>
    <published>2013-05-09T08:30:59.000Z</published>
    <updated>2014-04-27T04:55:23.000Z</updated>
    <content type="html"><![CDATA[<p>不知大家在使用 Win7/8 有没有遇到过拖拽文件到程序却无法打开的烦恼, 这个问题困扰了我很久, 今天终于有比较完美的方法, 感谢LEANKY给予的灵感.</p>
<p>可能有些朋友完全不会遇到这个问题, 其原因是他们一直都是开启和使用了内置管理员账号(Administrator), 在 Win8 中使用内置管理员账号会导致应用商城无法打开, 虽然可以通过修改组策略或注册表(导入下面注册表)来解决这问题. 但是我们回过头想想, 内置管理员账号所拥有的权限是很大的, 这会导致系统的安全性下降, 风险也会变大.</p>
<figure class="highlight reg"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Windows Registry Editor Version 5.00

; 内置Administrator管理员帐户使用应用商店
<span class="special">[</span>HKEY_LOCAL_MACHINE<span class="command">\SOFTWARE</span><span class="command">\Microsoft</span><span class="command">\Windows</span><span class="command">\CurrentVersion</span><span class="command">\Policies</span><span class="command">\System</span><span class="special">]</span>
"FilterAdministratorToken"=dword:00000001
</pre></td></tr></table></figure>

<p>当 UAC 彻底关闭的情况下也可以解决这个拖拽打开问题, 这个设置虽然不会影响到 Win7 用户, 但对于 Win8 用户会非常不方便, 应用商场会无法打开, 打开时会提示 UAC 必须开启, 破坏了系统的完整性! 更重要的还是安全问题, 因为 UAC 停用后, 任何程序都可以不经过用户确认后启动! 导入注册表彻底关闭 UAC 的方法:</p>
<figure class="highlight reg"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Windows Registry Editor Version 5.00

; 彻底关闭 UAC
<span class="special">[</span>HKEY_LOCAL_MACHINE<span class="command">\SOFTWARE</span><span class="command">\Microsoft</span><span class="command">\Windows</span><span class="command">\CurrentVersion</span><span class="command">\Policies</span><span class="command">\System</span><span class="special">]</span>
"EnableLUA"=dword:00000000
</pre></td></tr></table></figure>

<p>以上的方法是网上比较常见的解决方法, 然而这些方法都是以破坏系统安全性和完整性作为代价的, 经过我的测试并不可取.</p>
<a id="more"></a>

<p>参考了许多的文章, 原因是运行中的程序和文件管理器处于不同的权限运行, 权限低的程序无法访问权限高的程序, 而权限高的程序可以访问权限低的程序, 运行中的程序是管理员权限, 而文件管理器是 Users 权限或是低于管理员权限的权限, 所以这个时候我们只要提升文件管理器的权限.</p>
<p>起初我所想到的一个方法是结束掉当前的 Explorer.exe 进程, 然后使用任务管理器重新运行一个管理员权限的 Explorer 实例, 这个时候打开的文件管理器就有了与运行中的程序相同的管理员权限了(可能相同!), 这个时候应用商城是无法打开使用的, 做完需要的拖拽操作后, 就可以重新运行还原为当前用户权限的 Explorer 实例. 这个方法在我用过一次后就不想再用了, Explorer 换来换去烦不烦!</p>
<p>最后我参考了LEANKY的文章, 给了我很大的启发和灵感, 接下来就开始说明一下给”计算机”的右键菜单添加”以管理员身份打开”的方法, 这样打开后的”计算机”文件管理器就是管理员权限的了:</p>
<h2 id="删除相应注册表项">删除相应注册表项</h2>
<ol>
<li><p>打开注册表<code>[HKEY_CLASSES_ROOT\AppID\{CDCBCFCA-3CDC-436f-A4E2-0E02075250C2}]</code>, 这个时候我们没有权限删除<code>RunAs</code>键值, 那就修改权限吧. 右键<code>{CDCBCFCA-3CDC-436f-A4E2-0E02075250C2}</code>项-<code>权限...</code></p>
<p><img src="/images/2013/05/09/01.01.png" alt="该注册表项权限"></p>
</li>
<li><p>弹出该注册表项的权限窗口, 点击<code>高级</code>按钮</p>
<p><img src="/images/2013/05/09/01.02.png" alt="该注册表项权限窗口"></p>
</li>
<li><p>弹出高级安全设置对话框后, 点击<code>所有者</code>后面的<code>更改</code>, 在弹出的<code>选择用户或组</code>窗口中输入<code>Administrators</code>(不包括引号, <strong>注意要加<code>s</code></strong>), 2次确定后返回.</p>
<p><img src="/images/2013/05/09/01.03.png" alt="替换所有者为Administrators"></p>
</li>
<li><p>在<code>组或用户名</code>处选择<code>Administrators&quot;</code>, 勾选<code>Administrators 的权限</code>为<code>完全控制</code>后, 确定返回到注册表</p>
<p><img src="/images/2013/05/09/01.04.png" alt="使Administrators拥有完全控制权限"></p>
</li>
<li><p>这个时候就可以删除”RunAs”键值了, 右键<code>RunAs</code>键值, <code>删除</code>.</p>
<p><img src="/images/2013/05/09/01.05.png" alt="删除该注册表项中的RunAs键值"></p>
</li>
</ol>
<h2 id="创建计划任务">创建计划任务</h2>
<ol>
<li><p>打开<code>运行</code>, 输入<code>taskschd.msc</code>打开计划任务程序. 右键树状图中的<code>任务计划程序(本地)</code>, 弹出的菜单中选择<code>创建任务</code>, 或者直接单击最右边<code>操作</code>列表中列出的<code>创建任务</code>.</p>
<p><img src="/images/2013/05/09/02.01.png" alt="新建计划任务"></p>
</li>
<li><p>在弹出的创建任务对话框中的<code>常规</code>选项卡中, 输入<code>名称</code>, 名称可以根据自己喜欢输入, 因为后面需用到这个”名称”, 建议跟我一样填入<code>OpenComputerAsAdmin</code>. <code>安全选项</code>中勾选<code>使用最高权限运行</code>, <code>配置</code>下拉菜单中选择<code>Windows 8</code></p>
<p><img src="/images/2013/05/09/02.02.png" alt="创建OpenComputerAsAdmin计划任务之常规选项"></p>
</li>
<li><p>切换到<code>操作</code>选项卡, 点击<code>新建</code>按钮.</p>
<p><img src="/images/2013/05/09/02.03.png" alt="创建OpenComputerAsAdmin计划任务之操作选项卡"></p>
</li>
<li><p><code>操作</code>下拉列表中选择<code>启动程序</code>, <code>程序或脚本</code>中输入<code>%SystemRoot%\explorer.exe</code>, <code>添加参数</code>填入<code>,::{20D04FE0-3AEA-1069-A2D8-08002B30309D}</code>, 确定完成操作项目创建</p>
<p><img src="/images/2013/05/09/02.04.png" alt="创建OpenComputerAsAdmin计划任务之操作选项卡,新建操作"><br><img src="/images/2013/05/09/02.05.png" alt="创建OpenComputerAsAdmin计划任务之操作选项卡,新建操作完成"></p>
</li>
<li><p>切换到<code>条件</code>选项卡, 把<code>只有在计算机使用交流电源时才启动此任务</code>的勾去掉!</p>
<p><img src="/images/2013/05/09/02.06.png" alt="创建OpenComputerAsAdmin计划任务之条件选项卡"></p>
</li>
<li><p>切换到<code>设置</code>选项卡, 勾选<code>允许按需运行任务</code>, 去掉<code>如果任务运行时间超过以下时间, 停止任务:</code>前的勾, 在<code>如果此任务已经运行, 以下规则适用:</code>下拉菜单中选择<code>并行运行新实例</code>, 点击确定<em>完成任务的创建</em>.</p>
<p><img src="/images/2013/05/09/02.07.png" alt="创建OpenComputerAsAdmin计划任务之设置选项卡"><br><img src="/images/2013/05/09/02.08.png" alt="完成创建OpenComputerAsAdmin计划任务"></p>
</li>
</ol>
<h2 id="为桌面的”计算机”右键添加”以管理员身份打开”菜单">为桌面的”计算机”右键添加”以管理员身份打开”菜单</h2>
<ol>
<li><p>打开注册表导航到<code>[HKEY_CLASSES_ROOT\CLSID\{20D04FE0-3AEA-1069-A2D8-08002B30309D}\shell]</code>, 右键<code>新建一个项</code>, 命名为<code>OpenAsAdmin</code>, 修改默认值为<code>以管理员身份打开(&amp;A)</code>. 新建一个<code>字符串值</code>键值, 命名为<code>icon</code>, 修改其值为<code>%WinDir%\System32\imageres.dll,73</code></p>
<p><img src="/images/2013/05/09/03.01.png" alt="修改注册表&quot;计算机&quot;添加右键菜单&quot;以管理员方式打开&quot;"><br><img src="/images/2013/05/09/03.02.png" alt="添加OpenAsAdmin项"></p>
</li>
<li><p>右键<code>OpenAsAdmin</code>项, 新建一个项, 命名为<code>command</code>, 然后修改<code>默认</code>键值为<code>schtasks /Run /TN &quot;OpenComputerAsAdmin&quot;</code>, <em>这里的OpenComputerAsAdmin`就是2中创建的计划任务名称</em>, 如果你定义的名称不一样, 改成你的计划任务名称!</p>
<p><img src="/images/2013/05/09/03.03.png" alt="在OpenAsAdmin项添加command子项"></p>
</li>
<li><p>OK, 回到桌面我们就可以看到<code>&quot;计算机&quot;右键菜单</code>中已经添加成功!</p>
<p><img src="/images/2013/05/09/03.04.png" alt="成功创建以管理员身份打开菜单"></p>
</li>
</ol>
<p>当然你也可以省略3手动修改注册表, 使用导入注册表的方式更加方便快捷, 把下面内容保存为REG文件, (或<a href="http://pan.baidu.com/share/link?shareid=390861&amp;uk=218387942" title="计算机右键菜单添加以管理员方式打开 直接注册表导入REG文件" target="_blank">下载</a>, 提取密码：<code>g7ae</code>)直接导入即可:</p>
<figure class="highlight reg"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>Windows Registry Editor Version 5.00

<span class="special">[</span>HKEY_CLASSES_ROOT<span class="command">\CLSID</span><span class="command">\{</span>20D04FE0-3AEA-1069-A2D8-08002B30309D<span class="special">}</span><span class="command">\shell</span><span class="command">\OpenAsAdmin</span><span class="special">]</span>
@="以管理员身份打开(<span class="special">&</span>A)"
"icon"="<span class="comment">%WinDir%\\System32\\imageres.dll,73"</span>

; 注意: OpenComputerAsAdmin 改成你命名计划任务的名称!
<span class="special">[</span>HKEY_CLASSES_ROOT<span class="command">\CLSID</span><span class="command">\{</span>20D04FE0-3AEA-1069-A2D8-08002B30309D<span class="special">}</span><span class="command">\shell</span><span class="command">\OpenAsAdmin</span><span class="command">\command</span><span class="special">]</span>
@="schtasks /Run /TN <span class="command">\"</span>OpenComputerAsAdmin<span class="command">\"</span>"
</pre></td></tr></table></figure>

<p>问题比较完美的解决了, 以后只需要<code>右键&quot;计算机&quot;</code>菜单<code>以管理员打开</code>就能打开一个<em>管理员权限的”计算机”</em>了. 但还是不方便, 因为我们’只’把”计算机”提权, 当需要打开的文件在很深的目录时, 那就要先打开管理员权限的”计算机”, 然后就是麻烦的导航(一个个文件夹的打开), 如果在需要打开的文件所在的文件夹直接能以管理员权限打开这个文件夹就完美了, 我现在所想到的只是给文件夹增加一项菜单, 至于用什么命令还是未知数… 如果你有什么更好的方法, 请发帖讨论!</p>
<h2 id="推荐参考">推荐参考</h2>
<ul>
<li><a href="http://blog.sina.com.cn/s/blog_61268557010148hu.html" title="LEANKY BLOG - win8无法拖拽文件打开" target="_blank">win8无法拖拽文件打开</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_6126855701014naf.html" title="LEANKY BLOG - 续：win8拖拽文件无法打开" target="_blank">续：win8拖拽文件无法打开</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>不知大家在使用 Win7/8 有没有遇到过拖拽文件到程序却无法打开的烦恼, 这个问题困扰了我很久, 今天终于有比较完美的方法, 感谢LEANKY给予的灵感.</p>
<p>可能有些朋友完全不会遇到这个问题, 其原因是他们一直都是开启和使用了内置管理员账号(Administrator), 在 Win8 中使用内置管理员账号会导致应用商城无法打开, 虽然可以通过修改组策略或注册表(导入下面注册表)来解决这问题. 但是我们回过头想想, 内置管理员账号所拥有的权限是很大的, 这会导致系统的安全性下降, 风险也会变大.</p>
<figure class="highlight reg"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Windows Registry Editor Version 5.00

; 内置Administrator管理员帐户使用应用商店
<span class="special">[</span>HKEY_LOCAL_MACHINE<span class="command">\SOFTWARE</span><span class="command">\Microsoft</span><span class="command">\Windows</span><span class="command">\CurrentVersion</span><span class="command">\Policies</span><span class="command">\System</span><span class="special">]</span>
"FilterAdministratorToken"=dword:00000001
</pre></td></tr></table></figure>

<p>当 UAC 彻底关闭的情况下也可以解决这个拖拽打开问题, 这个设置虽然不会影响到 Win7 用户, 但对于 Win8 用户会非常不方便, 应用商场会无法打开, 打开时会提示 UAC 必须开启, 破坏了系统的完整性! 更重要的还是安全问题, 因为 UAC 停用后, 任何程序都可以不经过用户确认后启动! 导入注册表彻底关闭 UAC 的方法:</p>
<figure class="highlight reg"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>Windows Registry Editor Version 5.00

; 彻底关闭 UAC
<span class="special">[</span>HKEY_LOCAL_MACHINE<span class="command">\SOFTWARE</span><span class="command">\Microsoft</span><span class="command">\Windows</span><span class="command">\CurrentVersion</span><span class="command">\Policies</span><span class="command">\System</span><span class="special">]</span>
"EnableLUA"=dword:00000000
</pre></td></tr></table></figure>

<p>以上的方法是网上比较常见的解决方法, 然而这些方法都是以破坏系统安全性和完整性作为代价的, 经过我的测试并不可取.</p>
]]></summary>
    
      <category term="以管理员身份打开" scheme="http://liray.github.io/tags/%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E8%BA%AB%E4%BB%BD%E6%89%93%E5%BC%80/"/>
    
      <category term="优化" scheme="http://liray.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="右键菜单" scheme="http://liray.github.io/tags/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"/>
    
      <category term="拖拽" scheme="http://liray.github.io/tags/%E6%8B%96%E6%8B%BD/"/>
    
      <category term="注册表" scheme="http://liray.github.io/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    
      <category term="计算机" scheme="http://liray.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="Windows" scheme="http://liray.github.io/tags/Windows/"/>
    
      <category term="Windows 8" scheme="http://liray.github.io/tags/Windows%208/"/>
    
      <category term="Windows 系统维护" scheme="http://liray.github.io/categories/Windows%20%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Virtual CD-ROM Control Panel 微软 ISO 镜像虚拟光驱工具, 仅60kb!!]]></title>
    <link href="http://liray.github.io/2013/04/28/virtual-cd-rom-control-panel-60kb-only/"/>
    <id>http://liray.github.io/2013/04/28/virtual-cd-rom-control-panel-60kb-only/</id>
    <published>2013-04-28T10:20:19.000Z</published>
    <updated>2014-04-27T04:57:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>实用工具 Virtual CD-ROM Control Panel 可以让 Windows XP, Windows Vista 和 Windows 7 用户挂载 ISO 镜像文件为虚拟光驱. 对于读取磁盘映像安装软件或恢复备份文件是非常有用的.</p>
<p><img src="/images/2013/04/28/01.png" alt="微软 ISO 镜像虚拟光驱工具"><br><a id="more"></a></p>
<p><strong>注意</strong></p>
<blockquote>
<p>这个工具不受 Microsoft 的支持, 请自行承当风险. Windows 8 用户不需要这个工具. Windows 8 原生支持 ISO 文件. 如果你是 Windows 8 用户, 你可以直接把 ISO 文件打开 , Windows 就会挂载为一个虚拟光驱和自动分配一个盘符.</p>
<p>经测试该工具在 Windows 7 x64 环境里无法运行, 可能是64位系统的原因!</p>
<p>其实我们并不缺优秀的虚拟光驱工具, 例如DT等 , 但是由于这个虚拟光驱仅有60K大小, 所以在手头没有任何虚拟光驱工具的时候, 这个工具就能帮到手!</p>
</blockquote>
<h2 id="安装方法">安装方法</h2>
<ol>
<li>复制 VCdRom.sys 到 %systemroot%\system32\drivers 文件夹</li>
<li>运行 VCdControlTool.exe</li>
<li>点击”Driver control…”</li>
<li>如果”Install Driver”按钮可用就点击. 导航到 %systemroot%\system32\drivers 文件夹, 选择 VCdRom.sys, 同时打开.</li>
<li>点击”Start”</li>
<li>点击”OK”</li>
<li>点击”Add Drive”把一个驱动器添加到驱动器列表. 确保所添加的驱动器盘符不是本地驱动器的盘符. 如果是, 继续点击”Add Drive”, 直到添加一个没有使用的盘符为止</li>
<li>在驱动器列表上选择一个没有使用的盘符, 点击”Mount”.</li>
<li>导航到映像文件文件夹, 选择该映像文件, 然后点击”OK”. 不应该使用 UNC 命名规则, 但是映射为网络驱动应该没有问题.</li>
</ol>
<p>官方下载地址:<a href="http://www.microsoft.com/en-us/download/details.aspx?id=38780" title="Virtual CD-ROM Control Panel" target="_blank">Virtual CD-ROM Control Panel</a></p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>实用工具 Virtual CD-ROM Control Panel 可以让 Windows XP, Windows Vista 和 Windows 7 用户挂载 ISO 镜像文件为虚拟光驱. 对于读取磁盘映像安装软件或恢复备份文件是非常有用的.</p>
<p><img src="/images/2013/04/28/01.png" alt="微软 ISO 镜像虚拟光驱工具"><br>]]></summary>
    
      <category term="虚拟光驱" scheme="http://liray.github.io/tags/%E8%99%9A%E6%8B%9F%E5%85%89%E9%A9%B1/"/>
    
      <category term="软件" scheme="http://liray.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="精品软件" scheme="http://liray.github.io/categories/%E7%B2%BE%E5%93%81%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VHD系统启动时, 阻止动态扩展VHD扩展到完整大小]]></title>
    <link href="http://liray.github.io/2013/04/18/prevent-the-vhd-from-expanding-to-its-full-size/"/>
    <id>http://liray.github.io/2013/04/18/prevent-the-vhd-from-expanding-to-its-full-size/</id>
    <published>2013-04-18T09:34:45.000Z</published>
    <updated>2014-04-27T04:59:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>当系统启动时, 为了保证有足够的空间和防止数据损坏, 动态扩展VHD将扩大到其完整大小. 如果计算机无法分配足够的物理硬盘空间放置VHD, 它将会生成一个停止错误信息, 并且阻止操作系统继续启动.</p>
<p>当你只有一个VHD配置在计算机上时, 这通常不会出现问题. 然而, 当你有多个VHD时, 同时你不想使用VHD的所有空间时, 你可以通过调整注册表来阻止这种扩展. 有时候, 这也被称作”自动精简配置(thin provisioning)”.</p>
<p>这里有2中方式设置阻止动态扩展VHD扩展到完整大小. <strong>第一种</strong>是启动到系统后修改注册表的方式, <strong>另一种</strong>方式则进入Windows PE 后挂载VHD后修改系统组册表.</p>
<p>而这里只说明第一种设置方式, 第二种设置方式可以参考第一种方式操作.</p>
<h2 id="设置方法">设置方法</h2>
<p>启动到系统后, 打开”运行”, 输入”regedit”(不包括双引号)命令打开注册表, 定位到 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\FsDepends\Parameters 项, 修改 VirtualDiskExpandOnMount 的16进制数值为4, 重启电脑后生效.<br><a id="more"></a></p>
<p><img src="/images/2013/04/18/01.png" alt="REG : Virtual Disk Expand On Mount"></p>
<p>当然还可以使用直接导入的方式, 新建一个TXT记事本, 将以下内容拷贝到记事本, 保存后修改文件扩展名为”reg”, 双击导入注册表即可:</p>
<figure class="highlight reg"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>Windows Registry Editor Version 5.00

<span class="special">[</span>HKEY_LOCAL_MACHINE<span class="command">\SYSTEM</span><span class="command">\CurrentControlSet</span><span class="command">\Services</span><span class="command">\FsDepends</span><span class="command">\Parameters</span><span class="special">]</span>
"VirtualDiskExpandOnMount"=dword:00000004&lt;/pre&gt;
</pre></td></tr></table></figure>

<p>同时提供直接导入<strong>REG文件下载</strong>: <a href="http://pan.baidu.com/share/link?shareid=360354&amp;uk=218387942" title="阻止动态扩展VHD扩展到完整大小" target="_blank">VHDExpandOnMount.reg</a></p>
<p><span style="color: #ff0000;"><strong>注意:</strong> </span>该设置对固定大小( Fixed-size ) VHD 系统没有效果.</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://technet.microsoft.com/en-us/library/gg318055(v=ws.10).aspx" title="Scenario 3: Performing an Advanced Deployment of Native Boot VHDs" target="_blank">Scenario 3: Performing an Advanced Deployment of Native Boot VHDs</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>当系统启动时, 为了保证有足够的空间和防止数据损坏, 动态扩展VHD将扩大到其完整大小. 如果计算机无法分配足够的物理硬盘空间放置VHD, 它将会生成一个停止错误信息, 并且阻止操作系统继续启动.</p>
<p>当你只有一个VHD配置在计算机上时, 这通常不会出现问题. 然而, 当你有多个VHD时, 同时你不想使用VHD的所有空间时, 你可以通过调整注册表来阻止这种扩展. 有时候, 这也被称作”自动精简配置(thin provisioning)”.</p>
<p>这里有2中方式设置阻止动态扩展VHD扩展到完整大小. <strong>第一种</strong>是启动到系统后修改注册表的方式, <strong>另一种</strong>方式则进入Windows PE 后挂载VHD后修改系统组册表.</p>
<p>而这里只说明第一种设置方式, 第二种设置方式可以参考第一种方式操作.</p>
<h2 id="设置方法">设置方法</h2>
<p>启动到系统后, 打开”运行”, 输入”regedit”(不包括双引号)命令打开注册表, 定位到 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\FsDepends\Parameters 项, 修改 VirtualDiskExpandOnMount 的16进制数值为4, 重启电脑后生效.<br>]]></summary>
    
      <category term="VHD" scheme="http://liray.github.io/tags/VHD/"/>
    
      <category term="优化" scheme="http://liray.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="注册表" scheme="http://liray.github.io/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    
      <category term="Windows" scheme="http://liray.github.io/tags/Windows/"/>
    
      <category term="Windows 8" scheme="http://liray.github.io/tags/Windows%208/"/>
    
      <category term="Windows 系统维护" scheme="http://liray.github.io/categories/Windows%20%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Visual C++ Redistributable 运行库官方下载地址]]></title>
    <link href="http://liray.github.io/2012/12/07/download-vc-redistributable-runtimes/"/>
    <id>http://liray.github.io/2012/12/07/download-vc-redistributable-runtimes/</id>
    <published>2012-12-07T06:18:27.000Z</published>
    <updated>2014-04-27T05:03:11.000Z</updated>
    <content type="html"><![CDATA[<p>由于封装系统会用到，需要经常留意这些运行库的更新，所以就记录下它们相应的官方下载地址，以后懒得重新找。</p>
<h2 id="简介">简介</h2>
<p>这些包将安装 C 运行时 (CRT)、标准 C++、ATL、MFC、C++ AMP 和 OpenMP 库的运行时组件。</p>
<ol>
<li>VC++ 2005运行库</li>
</ol>
<ul>
<li><a href="http://www.microsoft.com/zh-cn/download/details.aspx?id=26347" title="VC++ 2005运行库 官方下载" target="_blank">Microsoft Visual C++ 2005 Service Pack 1 Redistributable Package</a></li>
</ul>
<ol>
<li>VC++ 2008运行库</li>
</ol>
<ul>
<li><a href="http://www.microsoft.com/zh-cn/download/details.aspx?id=26368" title="VC++ 2008运行库 官方下载" target="_blank">Microsoft Visual C++ 2008 Service Pack 1 Redistributable Package</a></li>
</ul>
<ol>
<li>VC++ 2010运行库</li>
</ol>
<ul>
<li><a href="http://www.microsoft.com/zh-cn/download/details.aspx?id=26999" title="VC++ 2010运行库 官方下载" target="_blank">Microsoft Visual C++ 2010 Service Pack 1 Redistributable Package</a></li>
</ul>
<ol>
<li>VC++ 2012运行库</li>
</ol>
<ul>
<li><a href="http://www.microsoft.com/zh-cn/download/details.aspx?id=30679" title="VC++ 2012运行库 官方下载" target="_blank">Visual C++ Redistributable for Visual Studio 2012 Update 4</a></li>
</ul>
<ol>
<li>VC++ 2013运行库</li>
</ol>
<ul>
<li><a href="http://www.microsoft.com/zh-CN/download/details.aspx?id=40784" title="VC++ 2013运行库 官方下载" target="_blank">Visual C++ Redistributable Packages for Visual Studio 2013</a></li>
</ul>
]]></content>
    
    
      <category term="Windows" scheme="http://liray.github.io/tags/Windows/"/>
    
      <category term="运行库" scheme="http://liray.github.io/tags/%E8%BF%90%E8%A1%8C%E5%BA%93/"/>
    
      <category term="c++" scheme="http://liray.github.io/tags/c++/"/>
    
      <category term="Windows 系统维护" scheme="http://liray.github.io/categories/Windows%20%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4/"/>
    
  </entry>
  
</feed>
